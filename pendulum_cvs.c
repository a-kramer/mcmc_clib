/*
 *  pendulum_cvs.c
 *
 *  CVODES C file for the vector field named: pendulum
 *
 *  This file was generated by the program VFGEN (Version:2.4.1)
 *  Generated on 31-Jan-2017 at 12:47
 */

#include <math.h>
/* Include headers for SUNDIALS v2.4.0, CVODES v2.6.0 */
#include <cvodes/cvodes.h> 
#include <cvodes/cvodes_dense.h> 
#include <nvector/nvector_serial.h> 
#include <sundials/sundials_types.h> 

typedef int (*rhs_f)(realtype, N_Vector, N_Vector, void *);
typedef int (*jac_f)(int, realtype,
                     N_Vector, N_Vector,
                     DlsMat, void*,
                     N_Vector, N_Vector, N_Vector);

typedef int (*rhs_sens)(int, realtype, N_Vector, N_Vector,
                        int, N_Vector, N_Vector,
                        void *, N_Vector, N_Vector);

typedef int (*func)(realtype, N_Vector, realtype *, void *);
typedef int (*func_sens)(realtype, N_Vector, N_Vector *, double *, void *);

typedef struct{
const int N;
const int P;
const int F;
const double* v;
const double* p;
rhs_f vf_eval;
jac_f vf_jac;
rhs_sens vf_sens;
func vf_func;
func_sens vf_func_sens;
const char** v_names;
const char** p_names;
const char** f_names;
void*	dylib;
} ode_model;

#define Pi  3.14159265358979323846264338
/*
 *  The vector field.
 */

int pendulum_vf(realtype t, N_Vector y_, N_Vector f_, void *params)
    {
    realtype theta, v;
    realtype g, b, L, m;
    realtype *p_;

    p_ = (realtype *) params;

    theta      = NV_Ith_S(y_,0);
    v          = NV_Ith_S(y_,1);

    g          = p_[0];
    b          = p_[1];
    L          = p_[2];
    m          = p_[3];

    NV_Ith_S(f_,0) = v;
    NV_Ith_S(f_,1) = -1.0/L*g*sin(theta)-b/(L*L)*v/m;
    return 0;
    }

/*
 *  The Jacobian.
 */

int pendulum_jac(int N_, realtype t,
                N_Vector y_, N_Vector fy_,
                DlsMat jac_, void *params,
                N_Vector tmp1, N_Vector tmp2, N_Vector tmp3)
    {
    realtype theta, v;
    realtype g, b, L, m;
    realtype *p_;

    p_ = (realtype *) params;

    theta      = NV_Ith_S(y_,0);
    v          = NV_Ith_S(y_,1);

    g          = p_[0];
    b          = p_[1];
    L          = p_[2];
    m          = p_[3];

    DENSE_ELEM(jac_, 0, 1) = 1.0;
    DENSE_ELEM(jac_, 1, 0) = -cos(theta)/L*g;
    DENSE_ELEM(jac_, 1, 1) = -b/(L*L)/m;
    return 0;
    }

/*
 *  Sensitivity functions 
 */

int pendulum_sens(int Ns_, realtype t, N_Vector y_, N_Vector ydot_,
                int iS_, N_Vector yS_, N_Vector ySdot_,
                void *params, N_Vector tmp1, N_Vector tmp2)
    {
    realtype theta, v;
    realtype g, b, L, m;
    realtype S0, S1;
    realtype *p_;

    p_ = (realtype *) params;

    theta      = NV_Ith_S(y_,0);
    v          = NV_Ith_S(y_,1);
    S0         = NV_Ith_S(yS_,0);
    S1         = NV_Ith_S(yS_,1);

    g          = p_[0];
    b          = p_[1];
    L          = p_[2];
    m          = p_[3];

    NV_Ith_S(ySdot_,0) = S1;
    NV_Ith_S(ySdot_,1) = -cos(theta)/L*S0*g-b/(L*L)/m*S1;

	switch (iS_) {
        case 0:
	            NV_Ith_S(ySdot_,1) += -1.0/L*sin(theta);
	        break;
        case 1:
	            NV_Ith_S(ySdot_,1) += -1.0/(L*L)*v/m;
	        break;
        case 2:
	            NV_Ith_S(ySdot_,1) +=  2.0*b/(L*L*L)*v/m+1.0/(L*L)*g*sin(theta);
	        break;
        case 3:
	            NV_Ith_S(ySdot_,1) += b/(L*L)*v/(m*m);
	        break;
	 }
    return 0;
    }

/*
 *  User-defined functions. 
 */

int pendulum_func(realtype t, N_Vector y_, realtype *func_, void *params)
    {
    realtype theta, v;
    realtype g, b, L, m;
    realtype *p_;

    p_ = (realtype *) params;

    theta      = NV_Ith_S(y_,0);
    v          = NV_Ith_S(y_,1);

    g          = p_[0];
    b          = p_[1];
    L          = p_[2];
    m          = p_[3];

    /* energy:  */
    func_[0] = -cos(theta)*L*m*g+(L*L)*(v*v)*m/2.0;
    return 0;
    }

/*
 *  Sensitivities of User-defined functions. 
 */

int pendulum_func_sens(realtype t, N_Vector y_, N_Vector * yS_, double* ret_, void *params)
    {
    realtype theta, v;
    realtype g, b, L, m;
    realtype *p_;

    p_ = (realtype *) params;

    theta      = NV_Ith_S(y_,0);
    v          = NV_Ith_S(y_,1);

    g          = p_[0];
    b          = p_[1];
    L          = p_[2];
    m          = p_[3];

    realtype yS_00, yS_01, yS_10, yS_11, yS_20, yS_21, yS_30, yS_31;
    yS_00 = NV_Ith_S(yS_[0 ],0);
    yS_01 = NV_Ith_S(yS_[0 ],1);
    yS_10 = NV_Ith_S(yS_[1 ],0);
    yS_11 = NV_Ith_S(yS_[1 ],1);
    yS_20 = NV_Ith_S(yS_[2 ],0);
    yS_21 = NV_Ith_S(yS_[2 ],1);
    yS_30 = NV_Ith_S(yS_[3 ],0);
    yS_31 = NV_Ith_S(yS_[3 ],1);

    /* g:  */
        ret_[0] =  (L*L)*yS_01*v*m+yS_00*L*m*g*sin(theta)-cos(theta)*L*m;
    /* b:  */
        ret_[1] =  L*m*g*yS_10*sin(theta)+yS_11*(L*L)*v*m;
    /* L:  */
        ret_[2] = -cos(theta)*m*g+L*yS_20*m*g*sin(theta)+L*(v*v)*m+(L*L)*v*m*yS_21;
    /* m:  */
        ret_[3] =  yS_31*(L*L)*v*m+yS_30*L*m*g*sin(theta)-cos(theta)*L*g+(L*L)*(v*v)/2.0;
    return 0;
    }

/* Initial conditions, names and ode_model structure */
const static double pendulum_init_v[2]={
                 RCONST( Pi-1.0000000000000000e-02),
                 RCONST(0.0000000000000000e+00)
            };

const static double pendulum_init_p[4]={
                 RCONST(9.8100000000000005e+00),
                 RCONST(1.0000000000000001e-01),
                 RCONST(1.0000000000000000e+00),
                 RCONST(1.0000000000000000e+00)
            };
    const static char *pendulum_varnames[2] = {"theta", "v"};
    const static char *pendulum_parnames[4] = {"g", "b", "L", "m"};
    const static char *pendulum_funcnames[1] = {"energy"};

ode_model  pendulum_odeModel = {2, 4, 1,
                     pendulum_init_v, pendulum_init_p,
                     &pendulum_vf, &pendulum_jac,
                     &pendulum_sens,
                     &pendulum_func,
                     &pendulum_func_sens,
                     pendulum_varnames, pendulum_parnames,
                     pendulum_funcnames, 0
                     };
